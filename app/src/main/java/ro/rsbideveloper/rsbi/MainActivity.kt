package ro.rsbideveloper.rsbi

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.usage.StorageStatsManager
import android.os.Build
import android.os.Bundle
import android.os.storage.StorageManager
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.ui.setupWithNavController
import com.google.android.material.navigation.NavigationView
import ro.rsbideveloper.rsbi.databinding.MainActivityBinding
import ro.rsbideveloper.rsbi.test.*

// <TODO> there is a possibility for the server to refuse / blacklist the client's
    // IP address, so handle that case as well (it blocked mine as I was using Tor, because
    // for some reason, rsbi.ro return a "Page not found" result from my local IP)
// <TODO> apparently a topic can have the comments section "closed"; I suppose they could also
    // be "deactivated" (which would imply deleting or hiding all existing comments, and making it
    // unable for new comments to be posted; a post could also have its comments sections be "cleaned",
    // or have a "filter" be applied on it (such as **** the curse words or inappropriate content, or
    // even confidential data that shouldn't be made public {but such filtering should be done server-side !})
// <TODO> a survey for "giving a talk at public engagement or other places"
// <TODO> what if someone wants to present a webinar in Romania ? -> "Want to present a talk ? Register here..."
    // and they could be added to a review list by admin(s) and enlisted in the next webinar
// <TODO> "Upload your presentation", again, for admin(s) review, or maybe even to the public
    // audience (access sharing control, ~ Google content in cloud)
// <TODO> an "Ask a (technical) question" mechanism, anyone can answer and the answers can be
    //  voted (up-voted and down-voted), just like StackOverflow, but local to the platform (can a user
    // have multiple answers ?)
// <TODO> mechanism for "Click on image to view it in full-resolution" (what if the image is much larger than the screen ?)
// <TODO> the "Beer and Science" could be facilitated online; all it does is have ~ 5-minute presentations,
    // which can be pre-recorded (which is preferably, be it for the anxious or for a better thought-out speech)
// <TODO> a "Donate" mechanism would be nice (~ Wikipedia or any other)
// <TODO> "newsletter" mechanism / subscription (is it an RSS feed ?); either way, the app also must have WhatsApp like
    // notifications whenever a new "event" (this is the general data type) is posted on the server and the client is
    // notified (or periodically checks the server for updates, at least once a day, or twice; this is necessary of the
    // clients because the server might not have a "subscribers" mechanisms that is easy to access for me, or to program);
    // ensure that the clients get updated at similar points in time, but spread them such as not to overload the server (so
    // maybe use a random hash algorithm to spread the client on a time interval, based on a ~ device-specific UUID)
// <TODO> have a mechanism through which to know how many people have installed and currently have installed the app,
    // and are using it
// <TODO> some pages have too much "HTML content" (mainly when a banner image is used in a post), so decide whether
    // to use WebView or to render just a part of the HTML content (or, worse for me but better for mobile, to parse
    // the HTML and extract the content; but then, how to render the image properly ? at best, I could add it as an
    // attachment); it's preferable to use WebView to render the HTML-CSS code and execute the Javascript
// <TODO> "We use Mailchimp as our marketing platform. By clicking below to subscribe, you acknowledge that your information will be transferred to Mailchimp for processing. Learn more about Mailchimp’s privacy practices here."
// <TODO> "This site uses Akismet to reduce spam. Learn how your comment data is processed." -> "Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security." from https://www.rsbi.ro/wp-comments-post.php
// <TODO> a mechanism to "alert / urgently communicate" with "members" and to privately communicate data with them; an
    // example of this is that so far they've been using the newsletter to communicate the zoom link for the general assembly in april,
    // and there was no "30/15 minute notification" beforehand, and they also needed 2/3 of the members to be present; as such,
    // webinar links should also be communicated similarly; the server is the centralization for accepting or refusing "webinar
    // participation requests"; although it's nice to use Zoom, the problem with it remains that it has no mechanism
    // for filtering participants based on a "secret" / id (?!), such as to prevent sabotage during the presentation, or
    // undesired presence, or spies, hackers, ..?
// <TODO> "Mulțumim lui Mihai, Robi și Bogdan pentru organizare și celor ce au luat cuvântul pentru contribuțiile aduse. Materialele din timpul întâlnirilor (prezentări, înregistrări) vor fi distribuite în curând."
    // well, while crawling the website, I haven't found these presentations anywhere; I have seen just some photos for the Beer and Science events;
    // so bottom line: a mechanism for uploading, downloading, visualizing presentations (preferably converted to .pdf client-side or server-side; avoid relying on .ppt viewers or any other dependencies,
    // all browsers can very well render .pdf files)
// <TODO> use an ActionBar or not ? the main reason for using one would be to have an indication of the current fragment,
    // but that could be done in many other ways I guess; and essentially, I'd only care about the ActionBar if it were a
    // necessity for the NavigationDrawer
// <TODO> what is this for ?
    //    private lateinit var appBarConfiguration: AppBarConfiguration
// <TODO> .xml assets, .html assets
    //    val loadedXML = assets.open("posts.html")
// <TODO> <*?> OptionsItem vs ContextItem -> what kind of items are the BottomNavBar's items ?
    // does the bottom nav bar need to be associated with the activity in Kotlin code, or ..?
    // or is there some default inflater being called that fails to make an association ?
    // why doesn't the NavController automatically match the item id's with the destination's id ?
    // or, how does onNavDestinationSelected() know which item is a selection and which isn't ?
    // apparently the bottom navigation bar is not properly set up ?
// <TODO> remove the app bar, the floating action button (could be used
    //  later for something ? maybe for adding a post, creating a webinar entry,
    //  remove menu items)
// <TODO> "are you a member ?" (members can add webinars)
// <TODO> webinar registration survey -> send email ? (RSBI server does this, I don't have access)
// <TODO> implement the bottom navigation bar such that the nav graph can be simpler [as it stands,
    // it needs to be a bidirectional K4 graph + that (Splashscreen -> Homepage)]
// <TODO> EXPERIMENTAL, services
    //        binding.serviceComStartBtn.setOnClickListener {
    //            Intent(this, ServiceCom::class.java).also {
    //                startService(it)
    //                // <TODO> use ViewModel; this decouples the modifier from having to track all the Observers / entities
    //                    // affected by changes here
    //                binding.serviceComState.text = "Service is running"
    //            }
    //        }
    //        binding.serviceComStopBtn.setOnClickListener {
    //            ServiceCom.stopService()
    //        }
    //        binding.serviceComSendBtn.setOnClickListener {
    //            Intent(this, ServiceCom::class.java).also {
    //                it.extras?.putString("data", binding.serviceComInput.text.toString())
    //                startService(it)
    //                binding.serviceComState.text = "Service is started with data being passed: ${binding.serviceComInput.text.toString()}"
    //            }
    //        }
// <TODO> any receiver then ? such as for alarm
    //    private lateinit var broadcastReceiver: AirplaneModeChangedBroadcastReceiver
// <TODO> setting the toolbar
// <TODO> I still think that the MainActivity should be the one to create an instance of the database,
    //  such that it could also be the done to handle background processes and requests for resynchronization
// which would happen irrespective of the current Fragment
// <TODO> at the moment, if there isn't an internet connection, the library throws an uncaught error and the app crashes
    // it should try to access the Internet and synchronize; if it fails, it will register a listener and upon Internet connection,
    // will attempt to download; it will keep a list of what has been synchronized and what not; the interrupt granularity will be
    // a page request
        //        broadcastReceiver = AirplaneModeChangedBroadcastReceiver()  // <TODO> supposedly there was something about a memory leak unless
        //                // the broadcastReceiver is unregistered in the onStop() lifecycle milestone / step
        //        IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED).also {
        //            registerReceiver(broadcastReceiver, it)
        //        }
// <TODO> DRAWER LAYOUT AND NAVIGATION DRAWER
    //  val navigationView = AppBarConfiguration(binding.MainActivityRootFragmentHost.findNavController().graph, binding.MainActivityRoot)
// <TODO> ALARM, NOTIFICATIONS, BROADCAST
    //  CreateNotificationManager()
    // private fun CreateNotificationManager() {
    //        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    //            val name: CharSequence = "Reminder Channel"
    //            val channel = NotificationChannel(AlarmReceiver.channelId, name, NotificationManager.IMPORTANCE_HIGH)
    //            channel.description = "A simple description"
    //
    //            val notificationManager = getSystemService(NotificationManager::class.java)
    //        }
    //    }
// <TODO> check if the registration link has a particular structure, so it could be extracted and presented directly into the
    // RecyclerView for faster access; then add markers for events that the app knows it is registered for; also add markers
    // for events that the app knows it has an alarm for
// <TODO> hide the Register and Alarm buttons in those articles that are not actually "events"
// <TODO> set maximum number of lines on title TextView: articles: 3 lines, others without author: maybe 4-5
// <TODO> in the offline mode of the WebView, can the errors of things which couldn't be loaded be hidden ?
// <TODO> for setting the alarm for an event, I think that just a few of the events will be able to have automatic alarms (if any...),
    // so there should be an indication ~ "alarm Auto" and "alarm Manual"; besides, note that any event should be able to
    // have multiple alarms (!)
// <TODO>


class MainActivity : AppCompatActivity() {

    private lateinit var viewModel: MainActivityViewModel
    private lateinit var binding: MainActivityBinding


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = MainActivityBinding.inflate(layoutInflater)
        setContentView(binding.root)

        /// ViewModel initialization
        viewModel = ViewModelProvider.AndroidViewModelFactory
            .getInstance(applicationContext as Application).create(MainActivityViewModel::class.java)
        viewModel.initialSynchronization()  // <TODO> this will handle setting up the behaviour in case of a lack of Internet connection

        /// Navigation initialization
        val navHostFragment = supportFragmentManager.findFragmentById(R.id.MainActivity_root_fragmentHost) as NavHostFragment
        val navController = navHostFragment.navController
        findViewById<NavigationView>(R.id.MainActivity_navigation_view)
            .setupWithNavController(navController)

        /// Cache and Persistent storage ??

    }


    override fun onStop() {
        super.onStop()
//        unregisterReceiver(broadcastReceiver)
    }

}

/// <TODO> Leftover code

//        binding.MainActivityBottomNav.setupWithNavController(navController)
//        setupActionBarWithNavController(navController)
//        setSupportActionBar(binding.toolbar)

//        val navController2 = findNavController(R.id.nav_host_fragment_container)
//        appBarConfiguration = AppBarConfiguration(navController.graph)
//        setupActionBarWithNavController(navController, appBarConfiguration)

//        binding.fab.setOnClickListener { view ->
//            Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
//                .setAction("Action", null).show()
//        }

/// COLLAPSING TOOLBAR
//        val layout = findViewById<CollapsingToolbarLayout>(R.id.collapsing_toolbar_layout)
//        val toolbar = findViewById<Toolbar>(R.id.toolbar)
//        val navHostFragment =
//            supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
//        val navController = navHostFragment.navController
//        val appBarConfiguration = AppBarConfiguration(navController.graph)
//        layout.setupWithNavController(toolbar, navController, appBarConfiguration)

/// ???
//    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
//        return super.onCreateOptionsMenu(menu)
//    }
//    override fun onContextItemSelected(item: MenuItem): Boolean {
//        return item.onNavDestinationSelected(
//            findNavController(R.id.MainActivity_fragment_host)
//        ) || super.onOptionsItemSelected(item)
//    }


//    override fun onOptionsItemSelected(item: MenuItem): Boolean {
//        // Handle action bar item clicks here. The action bar will
//        // automatically handle clicks on the Home/Up button, so long
//        // as you specify a parent activity in AndroidManifest.xml.
//        return item.onNavDestinationSelected(
//                findNavController(R.id.MainActivity_fragment_host)
//            ) || super.onOptionsItemSelected(item)
//    }


//    override fun onSupportNavigateUp(): Boolean {
//        val navController = findNavController(R.id.nav_host_fragment_content_main)
//        return navController.navigateUp(appBarConfiguration)
//                || super.onSupportNavigateUp()
//    }
//