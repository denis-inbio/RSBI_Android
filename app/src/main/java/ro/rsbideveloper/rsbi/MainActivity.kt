package ro.rsbideveloper.rsbi

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModelProvider
import com.bumptech.glide.Glide
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import org.jsoup.Jsoup
import ro.rsbideveloper.rsbi.data.article.Article
import ro.rsbideveloper.rsbi.data.pageHTML.PageHTML
import ro.rsbideveloper.rsbi.data.pageHTML.PageHTMLViewModel
import ro.rsbideveloper.rsbi.databinding.MainActivityBinding
import ro.rsbideveloper.rsbi.test.*

// <TODO> there is a possibility for the server to refuse / blacklist the client's
    // IP address, so handle that case as well (it blocked mine as I was using Tor, because
    // for some reason, rsbi.ro return a "Page not found" result from my local IP)
// <TODO> apparently a topic can have the comments section "closed"; I suppose they could also
    // be "deactivated" (which would imply deleting or hiding all existing comments, and making it
    // unable for new comments to be posted; a post could also have its comments sections be "cleaned",
    // or have a "filter" be applied on it (such as **** the curse words or inappropriate content, or
    // even confidential data that shouldn't be made public {but such filtering should be done server-side !})
// <TODO> a survey for "giving a talk at public engagement or other places"
// <TODO> what if someone wants to present a webinar in Romania ? -> "Want to present a talk ? Register here..."
    // and they could be added to a review list by admin(s) and enlisted in the next webinar
// <TODO> "Upload your presentation", again, for admin(s) review, or maybe even to the public
    // audience (access sharing control, ~ Google content in cloud)
// <TODO> an "Ask a (technical) question" mechanism, anyone can answer and the answers can be
    //  voted (up-voted and down-voted), just like StackOverflow, but local to the platform (can a user
    // have multiple answers ?)
// <TODO> mechanism for "Click on image to view it in full-resolution" (what if the image is much larger than the screen ?)
// <TODO> the "Beer and Science" could be facilitated online; all it does is have ~ 5-minute presentations,
    // which can be pre-recorded (which is preferably, be it for the anxious or for a better thought-out speech)
// <TODO> a "Donate" mechanism would be nice (~ Wikipedia or any other)
// <TODO> "newsletter" mechanism / subscription (is it an RSS feed ?); either way, the app also must have WhatsApp like
    // notifications whenever a new "event" (this is the general data type) is posted on the server and the client is
    // notified (or periodically checks the server for updates, at least once a day, or twice; this is necessary of the
    // clients because the server might not have a "subscribers" mechanisms that is easy to access for me, or to program);
    // ensure that the clients get updated at similar points in time, but spread them such as not to overload the server (so
    // maybe use a random hash algorithm to spread the client on a time interval, based on a ~ device-specific UUID)
// <TODO> have a mechanism through which to know how many people have installed and currently have installed the app,
    // and are using it
// <TODO> some pages have too much "HTML content" (mainly when a banner image is used in a post), so decide whether
    // to use WebView or to render just a part of the HTML content (or, worse for me but better for mobile, to parse
    // the HTML and extract the content; but then, how to render the image properly ? at best, I could add it as an
    // attachment); it's preferable to use WebView to render the HTML-CSS code and execute the Javascript
// <TODO> "We use Mailchimp as our marketing platform. By clicking below to subscribe, you acknowledge that your information will be transferred to Mailchimp for processing. Learn more about Mailchimp’s privacy practices here."
// <TODO> "This site uses Akismet to reduce spam. Learn how your comment data is processed." -> "Not Acceptable! An appropriate representation of the requested resource could not be found on this server. This error was generated by Mod_Security." from https://www.rsbi.ro/wp-comments-post.php
// <TODO> a mechanism to "alert / urgently communicate" with "members" and to privately communicate data with them; an
    // example of this is that so far they've been using the newsletter to communicate the zoom link for the general assembly in april,
    // and there was no "30/15 minute notification" beforehand, and they also needed 2/3 of the members to be present; as such,
    // webinar links should also be communicated similarly; the server is the centralization for accepting or refusing "webinar
    // participation requests"; although it's nice to use Zoom, the problem with it remains that it has no mechanism
    // for filtering participants based on a "secret" / id (?!), such as to prevent sabotage during the presentation, or
    // undesired presence, or spies, hackers, ..?
// <TODO> "Mulțumim lui Mihai, Robi și Bogdan pentru organizare și celor ce au luat cuvântul pentru contribuțiile aduse. Materialele din timpul întâlnirilor (prezentări, înregistrări) vor fi distribuite în curând."
    // well, while crawling the website, I haven't found these presentations anywhere; I have seen just some photos for the Beer and Science events;
    // so bottom line: a mechanism for uploading, downloading, visualizing presentations (preferably converted to .pdf client-side or server-side; avoid relying on .ppt viewers or any other dependencies,
    // all browsers can very well render .pdf files)
// <TODO> use an ActionBar or not ? the main reason for using one would be to have an indication of the current fragment,
    // but that could be done in many other ways I guess; and essentially, I'd only care about the ActionBar if it were a
    // necessity for the NavigationDrawer
// <TODO> what is this for ?
    //    private lateinit var appBarConfiguration: AppBarConfiguration
// <TODO> .xml assets, .html assets
    //    val loadedXML = assets.open("posts.html")
// <TODO> <*?> OptionsItem vs ContextItem -> what kind of items are the BottomNavBar's items ?
    // does the bottom nav bar need to be associated with the activity in Kotlin code, or ..?
    // or is there some default inflater being called that fails to make an association ?
    // why doesn't the NavController automatically match the item id's with the destination's id ?
    // or, how does onNavDestinationSelected() know which item is a selection and which isn't ?
    // apparently the bottom navigation bar is not properly set up ?
// <TODO> remove the app bar, the floating action button (could be used
    //  later for something ? maybe for adding a post, creating a webinar entry,
    //  remove menu items)
// <TODO> "are you a member ?" (members can add webinars)
// <TODO> webinar registration survey -> send email ? (RSBI server does this, I don't have access)
// <TODO> implement the bottom navigation bar such that the nav graph can be simpler [as it stands,
    // it needs to be a bidirectional K4 graph + that (Splashscreen -> Homepage)]
// <TODO> EXPERIMENTAL, services
    //        binding.serviceComStartBtn.setOnClickListener {
    //            Intent(this, ServiceCom::class.java).also {
    //                startService(it)
    //                // <TODO> use ViewModel; this decouples the modifier from having to track all the Observers / entities
    //                    // affected by changes here
    //                binding.serviceComState.text = "Service is running"
    //            }
    //        }
    //        binding.serviceComStopBtn.setOnClickListener {
    //            ServiceCom.stopService()
    //        }
    //        binding.serviceComSendBtn.setOnClickListener {
    //            Intent(this, ServiceCom::class.java).also {
    //                it.extras?.putString("data", binding.serviceComInput.text.toString())
    //                startService(it)
    //                binding.serviceComState.text = "Service is started with data being passed: ${binding.serviceComInput.text.toString()}"
    //            }
    //        }
// <TODO>

class MainActivity : AppCompatActivity() {

    private lateinit var binding: MainActivityBinding
    private lateinit var viewModel: PageHTMLViewModel
    private lateinit var broadcastReceiver: AirplaneModeChangedBroadcastReceiver
    private val articles: MutableList<Article> = mutableListOf()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = MainActivityBinding.inflate(layoutInflater)
        setContentView(binding.root)


//        val navHostFragment = supportFragmentManager.findFragmentById(R.id.MainActivity_fragment_host) as NavHostFragment
//        val navController = navHostFragment.navController
//
//
//        /// DRAWER LAYOUT AND NAVIGATION DRAWER
//        val drawerLayout = findViewById<DrawerLayout>(R.id.MainActivity_layout)
//        binding.MainActivityLayout
//        val appBarConfiguration = AppBarConfiguration(navController.graph, drawerLayout)
//
//
//        val navHostFragment2 =
//            supportFragmentManager.findFragmentById(R.id.MainActivity_fragment_host) as NavHostFragment
//        val navController2 = navHostFragment.navController
//        findViewById<NavigationView>(R.id.MainActivity_navigation_view)
//            .setupWithNavController(navController2)


        viewModel = ViewModelProvider.AndroidViewModelFactory
            .getInstance(applicationContext as Application).create(PageHTMLViewModel::class.java)


//        // <TODO> EXPERIMENTAL, getting HTML of pages
////        runBlocking {
////            getAllPages()
////        }

        broadcastReceiver = AirplaneModeChangedBroadcastReceiver()  // <TODO> supposedly there was something about a memory leak unless
                // the broadcastReceiver is unregistered in the onStop() lifecycle milestone / step
        IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED).also {
            registerReceiver(broadcastReceiver, it)
        }


        /// ALARM, NOTIFICATIONS, BROADCAST
        CreateNotificationManager()


        /// DOM parsing
        runBlocking(Dispatchers.IO) {
            synchronizeFeed()
        }
    }

    private fun extractArticles(codeHTML: String) {
        val document = Jsoup.parse(codeHTML)
        val articles = document.body().select("article")

        for(article in articles) {
            val title = article.select(".entry-title a").attr("title")
            val detailedArticleURL = article.select(".entry-title a").attr("href")
            val imgURL = article.select(".card-image img").attr("src")  // <TODO> might be missing, not all articles have a photo
            val content = article.select(".entry-summary p").text().toString().replace("Read more…", "", true) // <TODO> remove "Read more"
            val category = article.select(".category").text()
            val categoryURL = article.select(".category").attr("href")  // <TODO> missing
            val author = article.select("div .author a").attr("title")  // <TODO> there is the alternative with <b>.text()
            val authorURL = article.select("div .author a").attr("href")
            val creationTime = article.select(".entry-date").attr("datetime")
            val latestModificationTime = article.select(".updated").attr("datetime")

            Log.d("ARTICLES",
                "Title: $title\n" +
                    "DetailedArticleURL: $detailedArticleURL\n" +
                    "Image URL: $imgURL\n" +
                    "Content: $content\n" +
                    "Category: $category\n" +
                    "Category URL: $categoryURL\n" +
                    "Author: $author\n" +
                    "Author URL: $authorURL\n" +
                    "Creation Time: $creationTime\n" +
                    "Latest Modification Time: $latestModificationTime\n")

            Glide
                .with(this)
                .load(imgURL)
                .centerCrop()
                .placeholder(R.drawable.ic_baseline_search_24)
                .into(binding.MainActivityImageTest)

            binding.textView5.text = title
            binding.textView6.text = imgURL
            binding.textView7.text = category
            binding.textView8.text = content
        }



    }

    private suspend fun synchronizeFeed() {
            // <TODO> Order of asynchronous retrieval, one page request at a time, but
                // asynchronously synchronized with the (Ui -> observe: ViewModel)

        // RSBI events
        // External events
        // Public engagement
        // Blog
        // Job offers

        val URLs = resources.getStringArray(R.array.articles_urls)

//        <string-array name="events_or_feed">
//        <item>https://www.rsbi.ro/category/rsbi-events/</item>
//        <item>https://www.rsbi.ro/category/external-events/</item>
//        <item>https://www.rsbi.ro/category/public-engagement/</item>
//        <item>https://www.rsbi.ro/category/blog/</item>
//        <item>https://www.rsbi.ro/category/current-job-offers/</item>

        for(URL in URLs) {
            Log.d("SYNCFEED", "Synchronizing $URL")
            try {
                val codeHTML = getHTML(URL)
//                Log.d("SYNCFEED", "HTML code: $codeHTML")

                // <TODO> compute its hash or whatever is needed to check for updates in future requests
                    // this is related to learning about HTTP requests and how the UPDATE request / method works

                // <TODO> parse the HTML and extract the <article> tags; check for Next <a> and get those as well,
                    // corroborating the data (from all URLs ?) in a single list
//                val pageHTML = PageHTML(0, URL, codeHTML)
//                viewModel.addPageHTML(pageHTML)
//                Log.d("VIEWMODEL", "Added a local copy of the URL ${URL}")

                extractArticles(codeHTML)

            } catch(e: Exception) {
                Log.d("SYNCFEED", "Exception: ${e.message}")
            }
        }
    }


    suspend fun getAllPages() {
        val pagesHtml: MutableList<String> = mutableListOf()
        val URLs = resources.getStringArray(R.array.RSBI_pages_URLs)
        for(URL in URLs) {
            Log.d("TAG", "URLs list: ${URL}")
            try {
                val content = getHTML(URL)
                Log.d("CONTENT", content)

                // <TODO> add to a database, check for update, etc.
                val pageHTML = PageHTML(0, URL, content)
                viewModel.addPageHTML(pageHTML)
                Log.d("VIEWMODEL", "Added a local copy of the URL ${URL}")

            } catch(e: Exception) {
                Log.d("TAG", "Exception: ${e.message}")
            }
        }
        Log.d("TAG", pagesHtml.size.toString())
    }

    suspend fun getHTML(URL: String): String {
        val client = HttpClient(CIO)
        val response: HttpResponse = client.get(URL)
        //        Log.d("TAG", response.toString())
        //        Log.d("TAG", response.headers.toString())
        //        Log.d("TAG", response.call.toString())

        var content = StringBuilder()
        var line: String? = ""

        while(line != null) {
            //            Log.d("TAG", line)
            content.append(line)
            line = response.content.readUTF8Line(10000)
        }
        client.close()

        return content.toString()
    }


    override fun onStop() {
        super.onStop()
        unregisterReceiver(broadcastReceiver)
    }

    private fun CreateNotificationManager() {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name: CharSequence = "Reminder Channel"
            val channel = NotificationChannel(AlarmReceiver.channelId, name, NotificationManager.IMPORTANCE_HIGH)
            channel.description = "A simple description"

            val notificationManager = getSystemService(NotificationManager::class.java)
        }
    }
}

/// <TODO> Leftover code

//        binding.MainActivityBottomNav.setupWithNavController(navController)
//        setupActionBarWithNavController(navController)
//        setSupportActionBar(binding.toolbar)

//        val navController2 = findNavController(R.id.nav_host_fragment_container)
//        appBarConfiguration = AppBarConfiguration(navController.graph)
//        setupActionBarWithNavController(navController, appBarConfiguration)

//        binding.fab.setOnClickListener { view ->
//            Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
//                .setAction("Action", null).show()
//        }

/// COLLAPSING TOOLBAR
//        val layout = findViewById<CollapsingToolbarLayout>(R.id.collapsing_toolbar_layout)
//        val toolbar = findViewById<Toolbar>(R.id.toolbar)
//        val navHostFragment =
//            supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
//        val navController = navHostFragment.navController
//        val appBarConfiguration = AppBarConfiguration(navController.graph)
//        layout.setupWithNavController(toolbar, navController, appBarConfiguration)

/// ???
//    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
//        return super.onCreateOptionsMenu(menu)
//    }
//    override fun onContextItemSelected(item: MenuItem): Boolean {
//        return item.onNavDestinationSelected(
//            findNavController(R.id.MainActivity_fragment_host)
//        ) || super.onOptionsItemSelected(item)
//    }


//    override fun onOptionsItemSelected(item: MenuItem): Boolean {
//        // Handle action bar item clicks here. The action bar will
//        // automatically handle clicks on the Home/Up button, so long
//        // as you specify a parent activity in AndroidManifest.xml.
//        return item.onNavDestinationSelected(
//                findNavController(R.id.MainActivity_fragment_host)
//            ) || super.onOptionsItemSelected(item)
//    }


//    override fun onSupportNavigateUp(): Boolean {
//        val navController = findNavController(R.id.nav_host_fragment_content_main)
//        return navController.navigateUp(appBarConfiguration)
//                || super.onSupportNavigateUp()
//    }
//

/// ??
//    private fun getHtmlFromWeb() {
//        Thread(Runnable {
//            val stringBuilder = StringBuilder()
//            try {
//                val doc: Document = Jsoup.connect("http://www.tutorialspoint.com/").get()
//                val title: String = doc.title()
//                val links: Elements = doc.select("a[href]")
//                stringBuilder.append(title).append("\n")
//                for (link in links) {
//                    stringBuilder.append("\n").append("Link :
//                        ").append(link.attr("href")).append("\n").append("Text : ").append(link.text())
//                }
//            } catch (e: IOException) {
//                stringBuilder.append("Error : ").append(e.message).append("\n")
//            }
//            runOnUiThread { textView.text = stringBuilder.toString() }
//        }).start()
//    }
